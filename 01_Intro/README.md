# Architecture

![image](https://github.com/MuraliAirody/Java-Learning/assets/71452201/ab3ecfa3-385f-405d-b14f-29f275b884a8)

### Source Code
 The code written in java is in human readable form. which is stored in a .java extension file.

### Java Compiler

which converts the source code into byte code which is having .class extension 

byte code is not directly run on the system
we need a JVM to run the byte code

Reason why java is system independent

### Java Interpreter

converts the byte code into machine understandable format which is 0s and 1s

it translate byte code line by line into machine code 

![image](https://github.com/MuraliAirody/React_Learning/assets/71452201/75c0d589-eab2-4468-9cc7-33a9e907689e)


### JDK: 
1. provide environment to develop and run java program
2. its a package That includes

- development tools
- JRE
- compiler: javac
- Archiver: jar
- Docs generator: javadocs
- interpreter/loader

### [More about JDK from GFG](https://www.geeksforgeeks.org/jdk-in-java/?ref=lbp)

### JRE
1. it's an installation package that is used to run the java program
2. it consist of

- deployment technology
- user interface toolkit
- integration libraries
- base libraries
- JVM

**after we got the .class file further things happens at runtime**

1. class Loader loads all the classes which need to be execute the program
2. JVM sends the code to byte code verifier to check the format of the code

### JVM
JVM(Java Virtual Machine) acts as a run-time engine to run Java applications. JVM is the one that actually calls the main method present in a Java code. JVM is a part of JRE(Java Runtime Environment).

Java applications are called WORA (Write Once Run Anywhere). This means a programmer can develop Java code on one system and can expect it to run on any other Java-enabled system without any adjustment. This is all possible because of JVM.

**JVM Working**

#### 1. loading<br>
The Class loader reads the “.class” file, generate the corresponding binary data and save it in the method area. For each “.class” file, JVM stores the following information in the method area. <br>
The fully qualified name of the loaded class and its immediate parent class. <br>
Whether the “.class” file is related to Class or Interface or Enum. <br>
Modifier, Variables and Method information etc.<br>
After loading the “.class” file, JVM creates an object of type Class to represent this file in the heap memory. Please note that this object is of type Class predefined in java.lang package. These Class object can be used by the programmer for getting class level information like the name of the class, parent name, methods and variable information etc. To get this object reference we can use getClass() method of Object class
#### 2. linking<br>
**Verification**: It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.<br>VerifyError. This activity is done by the component ByteCodeVerifier. Once this activity is completed then the class file is ready for compilation.<br>
**Preparation**: JVM allocates memory for class static variables and initializing the memory to default values. <br>
**Resolution**: It is the process of replacing symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.
#### 3. initializing<br>
In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy.


#### JVM Execution
1. interpreter
  line by line execution
  when one method is called again and again in a program, it will interpret agin and again

2. JIT
 Method which are repeated again and again,JIT provide direct machine code for that and avoid the interpreting again and again<br>
 Makes the execution faster<br>
 garbage collector<br>

### [More about JVM from GFG](https://www.geeksforgeeks.org/jvm-works-jvm-architecture/?ref=lbp)